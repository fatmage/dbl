pub let length xs = 
  let rec length_aux xs (res : Int) =
    match xs with 
    | []      => res 
    | x :: xs => length_aux xs (res + 1)
    end 
  in length_aux xs 0

pub let hd  xs =
  match xs with 
  | []      => None
  | x :: xs => Some x
  end

pub let hd_err {`onError : {type X} -> Unit ->[|_] X} xs =
  match xs with 
  | []      => `onError () 
  | x :: xs => x 
  end 

pub let tl xs =
  match xs with 
  | []      => None
  | x :: xs => Some xs
  end

pub let tl_err {`onError : {type X} -> Unit ->[|_] X} xs =
  match xs with 
  | []      => `onError ()
  | x :: xs => xs 
  end 

pub let nth xs (n : Int) = 
  let rec nth_aux xs (n : Int) =
    match xs with 
    | []      => None 
    | x :: xs => if n == 0 then Some x else nth_aux xs (n - 1)
    end 
  in if n < 0 then None else nth_aux xs n

pub let nth_err {`onError : {type X} -> Unit ->[|_] X} xs (n : Int) = 
  let rec nth_err_aux xs (n : Int) =
    match xs with 
    | []      => `onError () 
    | x :: xs => if n == 0 then x else nth_err_aux xs (n - 1)
    end 
  in if n < 0 then `onError () else nth_err_aux xs 0

pub let rec append xs ys =
  match xs with
  | []      => ys
  | x :: xs => x :: append xs ys
  end

pub let rec rev_append xs acc = 
  match xs with 
  | []      => acc 
  | x :: xs => rev_append xs (x :: acc)
  end 

pub let rev xs = rev_append xs []

pub let rec concat xss =
  match xss with
  | []        => []
  | xs :: xss => append xs (concat xss)
  end

pub let flatten = concat

pub let rec map f xs =
  match xs with
  | []      => []
  | x :: xs => f x :: map f xs
  end

pub let mapi f xs = 
  let rec mapi_aux (i : Int) f xs =
    match xs with 
    | []      => []
    | x :: xs => (f i x) :: mapi_aux (i+1) f xs
    end 
  in mapi_aux 0 f xs

pub let rec rev_map_append f xs ys =
  match xs with 
  | []      => ys 
  | x :: xs => rev_map_append f xs (f x :: ys)
  end 

pub let rev_map f xs = rev_map_append f xs []

pub let rec filter f xs =
  match xs with
  | []      => []
  | x :: xs => if f x then x :: filter f xs else filter f xs
  end

pub let filteri p xs = 
  let rec filteri_aux p (i : Int) xs =
    match xs with 
    | []      => [] 
    | x :: xs => if p i x then x :: filteri_aux p (i + 1) xs else filteri_aux p (i + 1) xs
    end 
  in filteri_aux p 0 xs

pub let rec filter_map f xs =
  match xs with 
  | []      => []
  | x :: xs => 
    match f x with 
    | None   => filter_map f xs 
    | Some x => x :: filter_map f xs 
    end 
  end

pub let concat_map f xs = concat (map f xs)

pub let rec take (n : Int) xs = 
  match xs with 
  | []      => [] 
  | x :: xs => if n == 0 then [] else x :: take (n - 1) xs 
  end

pub let rec drop (n : Int) xs =
  if n <= 0 then xs else 
    match xs with 
    | []      => [] 
    | x :: xs => drop (n - 1) xs 
    end 

pub let rec take_while p xs =
  match xs with 
  | []      => []
  | x :: xs => if p x then x :: take_while p xs else []
  end 

pub let rec drop_while p xs =
  match xs with 
  | []       => [] 
  | x :: xs' => if p x then drop_while p xs' else xs 
  end 

pub let rec iter f xs =
  match xs with
  | []      => ()
  | x :: xs => let () = f x in iter f xs
  end

pub let iteri f xs =
  let rec iteri_aux (i : Int) xs =
    match xs with 
    | []    => () 
    | x :: xs => let _ = f i x in iteri_aux (i + 1) xs 
    end 
  in iteri_aux 0 xs

pub let iter2 {`onError : {type X} -> Unit ->[|_] X} =
  let rec iter f xs ys =
    match xs, ys with
    | [],      []      => ()
    | x :: xs, y :: ys => let () = f x y in iter f xs ys
    | _                => `onError ()
  end
  in iter

pub let init (len : Int) f = 
  let rec init_aux (i : Int) f = 
    if i > len - 1 then [] 
    else (f i) :: init_aux (i+1) f 
  in init_aux 0 f

pub let rec fold_left f acc xs = 
  match xs with
  | []      => acc 
  | x :: xs => fold_left f (f acc x) xs 
  end 

pub let rec fold_right f xs acc =
  match xs with 
  | []      => acc 
  | x :: xs => f x (fold_right f xs acc)
  end 

pub let rec for_all p xs =
  match xs with 
  | []      => True 
  | x :: xs => p x && for_all p xs
  end 

pub let rec exists p xs =
  match xs with 
  | []      => False 
  | x :: xs => p x || exists p xs 
  end

pub let find_err {`onError : {type X} -> Unit ->[|_] X} p xs = 
  let rec find_err_aux p xs =
    match xs with 
    | []      => `onError () 
    | x :: xs => if p x then x else find_err_aux p xs 
    end  
  in find_err_aux p xs

pub let rec find p xs =
  match xs with 
  | []      => None 
  | x :: xs => if p x then Some x else find p xs 
  end 

pub let rec find_index_opt p xs = 
  let rec find_index_opt_aux p (i : Int) xs =
    match xs with 
    | []      => None 
    | x :: xs => if p x then Some i else find_index_opt_aux p (i + 1) xs
    end
  in find_index_opt_aux p 0 xs

pub let find_map_err {`onError : {type X} -> Unit ->[|_] X} f xs =
  let rec find_map_err_aux f xs =
    match xs with
    | []      => `onError () 
    | x :: xs => 
      match f x with
      | None   => find_map_err_aux f xs
      | Some x => x
      end 
    end 
  in find_map_err_aux f xs

pub let rec find_map f xs =
  match xs with 
  | []      => None 
  | x :: xs => 
    match f x with 
    | Some x  => Some x
    | None    => find_map f xs 
    end 
  end

pub let find_mapi f xs = 
  let rec find_mapi_aux (i : Int) xs = 
    match xs with 
    | []      => None 
    | x :: xs => 
      match f i x with 
      | Some x' => Some x'
      | None    => find_mapi_aux (i + 1) xs 
      end 
    end 
  in find_mapi_aux 0 xs

pub let find_mapi_err {`onError : {type X} -> Unit ->[|_] X} f xs =
  let rec find_mapi_err_aux (i : Int) xs =
    match xs with 
    | []      => `onError ()
    | x :: xs =>
      match f i x with 
      | Some x => x 
      | None   => find_mapi_err_aux (i + 1) xs 
      end 
    end 
  in find_mapi_err_aux 0 xs

pub let find_all = filter

pub let fold_left_map f acc xs =
  let rec fold_left_map_aux acc l_acc xs = 
    match xs with 
    | [] => acc, rev l_acc
    | x :: xs =>
      let (acc, x) = f acc x in 
      fold_left_map_aux acc (x :: l_acc) xs
    end
  in fold_left_map_aux acc [] xs

pub let fold_right_map f xs acc = 
  let rec fold_right_map_aux xs acc r_acc =
    match xs with 
    | [] => acc, r_acc
    | x :: xs =>
      let (acc, x) = f x acc in
      fold_right_map_aux xs acc (x :: r_acc)
    end
  in fold_right_map_aux (rev xs) acc []

pub let is_empty xs =
  match xs with 
  | [] => True 
  | _  => False 
  end

pub method length = length self
pub method map f = map f self 
pub method add ys = append self ys 
pub method filter f = filter f self
