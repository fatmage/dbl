(*
  xoroshiro128++ PRNG
  https://prng.di.unimi.it/
 *)

(* Standard state effect with its accompanying methods *)
data State (effect E) X = State of
  { get    : Unit ->[E] X
  , put    : X ->[E] Unit
  , update : {Row} -> (X ->[E|Row] X) ->[E|Row] Unit
  }

implicit ~randSt {E_st} : State E_st _

let get x = let (State { get }) = ~randSt in get x
let put x = let (State { put }) = ~randSt in put x
let update f = let (State { update }) = ~randSt in update f

(* Standard state handler *)
handle {effect=Rand} (~randSt : State Rand (Pair Int64 Int64)) =
  let get = effect x / r => fn s => r s  s
  let put = effect s / r => fn _ => r () s
  let update f = put (f (get ())) in
    State { get, put, update }
  return  x => fn _ => x
  finally c => c (0L, 0L)

let getSeed = extern dbl_getSeed : Unit -> Int64

(* splitmix64 algorithm for generating seeds for the proper PRNG *)
let splitmix64 (seed : Int64) =
  let z0 = seed + 0x9e3779b97f4a7c15L in
  let z1 = (z0 ^^^ (z0 >> 30L)) * 0xbf58476d1ce4e5b9L in
  let z2 = (z1 ^^^ (z1 >> 27L)) * 0x94d049bb133111ebL in
  z0, z2 ^^^ (z2 >> 31L)

let rotl (x : Int64) (k : Int64) = (x << k) ||| (x >> (64L - k))

let next () =
  let (s0, s1) = get () in
  let s1' = s1 ^^^ s0 in
  let _ = put (((rotl s0 49L) ^^^ s1') ^^^ (s1' << 21L), rotl s1' 28L) in
  (rotl (s0 + s1) 17L) + s0

pub let init (seed : Int64) =
  let (nextSeed, s0) = splitmix64 seed in
  put (s0, snd (splitmix64 nextSeed))

pub let selfInit () = init (getSeed ())

implicit ~re
let ~re = fn () => exit 1

pub let int n = (next ()).toInt % n
pub let int64 n = (next ()) % n
pub let bool () = next () < 0L