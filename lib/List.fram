{# This file is part of DBL, released under MIT license.
 # See LICENSE for details.
 #}

## # List operations

## Check if a list is empty.
pub let isEmpty xs =
  match xs with
  | [] => True
  | _  => False
  end

## Return the length of a list (number of elements).
pub let length xs =
  let rec lengthAux xs (res : Int) =
    match xs with
    | []      => res
    | x :: xs => lengthAux xs (res + 1)
    end
  in lengthAux xs 0

## Return the first element of a list or `None` if it's empty.
pub let hd xs =
  match xs with
  | []      => None
  | x :: xs => Some x
  end

## Return the first element of a list or call `~onError` if it's empty.
pub let hdErr { ~onError } xs =
  match xs with
  | []      => ~onError ()
  | x :: xs => x
  end

## Return the list without its first element or `None` if it's empty.
pub let tl xs =
  match xs with
  | []      => None
  | x :: xs => Some xs
  end

## Return the list without its first element or call `~onError` if it's empty
pub let tlErr { ~onError } xs =
  match xs with
  | []      => ~onError ()
  | x :: xs => xs
  end

{## Return the n-th element of a list or `None` if n is negative or the list
  is too short. The first element is at position 0. ##}
pub let nth xs (n : Int) =
  let rec nthAux xs (n : Int) =
    match xs with
    | []      => None
    | x :: xs => if n == 0 then Some x else nthAux xs (n - 1)
    end
  in if n < 0 then None else nthAux xs n

{## Return the n-th element of a list or call `~onError` if n is negative
  or the list is too short. The first element is at position 0. ##}
pub let nthErr { ~onError } xs (n : Int) =
  let rec nthErrAux xs (n : Int) =
    match xs with
    | []      => ~onError ()
    | x :: xs => if n == 0 then x else nthErrAux xs (n - 1)
    end
  in if n < 0 then ~onError () else nthErrAux xs n

## `apppend xs ys` appends `ys` to `xs`.
pub let rec append xs ys =
  match xs with
  | []      => ys
  | x :: xs => x :: append xs ys
  end

## `revAppend xs ys` reverses `xs` and appends it to `ys`
pub let rec revAppend xs acc =
  match xs with
  | []      => acc
  | x :: xs => revAppend xs (x :: acc)
  end

## Return the given list reversed.
pub let rev xs = revAppend xs []

{## Concatenate a list of lists. The elements of the given list are appended
  to each other consecutively. ##}
pub let rec concat xss =
  match xss with
  | []        => []
  | xs :: xss => append xs (concat xss)
  end

{## `map f xs` applies `f` to elements of `xs` and returns a list
  constructed from the results of these applications. ##}
pub let rec map f xs =
  match xs with
  | []      => []
  | x :: xs => f x :: map f xs
  end

{## Same as `List.map`, but it takes an additional optional parameter `i`
  whose default value is 0 and `f` takes an additional argument `i` which is
  incremented with every consecutive application. ##}
pub let rec mapi { ?i : Int } f xs =
  match i with
  | None   => mapi {i = 0} f xs
  | Some i =>
    match xs with
    | []      => []
    | x :: xs => f i x :: mapi {i = i + 1} f xs
    end
  end

{## `map2 f xs ys` returns a list constructed by applying `f` to consecutive
  pairs of elements from `xs` and `ys.
  Calls `~onError` if the lists have different lengths. ##}
pub let map2 { ~onError } f xs ys =
  let rec map2Aux xs ys =
    match xs, ys with
    | [],      []      => []
    | x :: xs, y :: ys => f x y :: map2Aux xs ys
    | _,       _       => ~onError ()
    end
  in map2Aux xs ys

## `revMapAppend f xs ys` maps `f` onto reversed `xs` and appends it to `ys`.
pub let rec revMapAppend f xs ys =
  match xs with
  | []      => ys
  | x :: xs => revMapAppend f xs (f x :: ys)
  end

## `revMap f xs` returns `f` mapped onto reversed `xs`.
pub let revMap f xs = revMapAppend f xs []

{## `revMap2 f xs ys` returns a list constructed by applying `f` to consecutive
  pairs of elements from reversed `xs` and `ys`.
  Calls `~onError` if the lists have different lengths. ##}
pub let revMap2 { ~onError } f xs ys =
  let rec revMap2Aux acc xs ys =
    match xs, ys with
    | [],      []      => acc
    | x :: xs, y :: ys => revMap2Aux (f x y :: acc) xs ys
    | _,       _       => ~onError ()
    end
  in revMap2Aux [] xs ys

## `filter p xs` returns list of elements of `xs` which satisfy predicate `p`.
pub let rec filter p xs =
  match xs with
  | []      => []
  | x :: xs => if p x then x :: filter p xs else filter p xs
  end

{## Same as `List.filter`, but it takes an additional optional parameter `i`
  whose default value is 0 and `p` takes an additional argument `i` which is
  incremented with every consecutive application. ##}
pub let rec filteri { ?i : Int } p xs =
  match i with
  | None   => filteri {i = 0} p xs
  | Some i =>
    match xs with
    | []      => []
    | x :: xs =>
      if p i x then x :: filteri {i = i + 1} p xs
      else filteri {i = i + 1} p xs
    end
  end

{## Same as `List.filter`, but `f` returns an `Option`. Returns a list of
  arguments on which `f` returned `Some`. ##}
pub let rec filterMap f xs =
  match xs with
  | []      => []
  | x :: xs =>
    match f x with
    | None   => filterMap f xs
    | Some x => x :: filterMap f xs
    end
  end

## Same as `List.filterMap` and `List.filteri`.
pub let rec filterMapi { ?i : Int } f xs =
  match i with
  | None   => filterMapi {i = 0} f xs
  | Some i =>
    match xs with
    | []      => []
    | x :: xs =>
      match f x i with
      | None   => filterMapi {i = i + 1} f xs
      | Some x => x :: filterMapi {i = i + 1} f xs
      end
    end
  end

## `concatMap f xs` maps `f` onto `xs` and then concatenates the result.
pub let concatMap f xs = concat (map f xs)

## Return prefix of length n of a list or the list itself if its shorter than n.
pub let rec take (n : Int) xs =
  match xs with
  | []      => []
  | x :: xs => if n == 0 then [] else x :: take (n - 1) xs
  end

## Return suffix of a list after n elements or `[]` if its shorter than n,
pub let rec drop (n : Int) xs =
  if n <= 0 then xs else
    match xs with
    | []      => []
    | x :: xs => drop (n - 1) xs
    end

## Return the longest prefix of a list whose elements satisfy `p`.
pub let rec takeWhile p xs =
  match xs with
  | []      => []
  | x :: xs => if p x then x :: takeWhile p xs else []
  end

## Return the longest suffix of a list whose first element satisfies `p`.
pub let rec dropWhile p xs =
  match xs with
  | []       => []
  | x :: xs' => if p x then dropWhile p xs' else xs
  end

## `iter f xs` applies `f` to all elements of `xs` in order.
pub let rec iter f xs =
  match xs with
  | []      => ()
  | x :: xs => f x; iter f xs
  end

{## Same as `List.iter`, but it takes an additional optional parameter `i`
  whose default value is 0 and `f` takes and additional argument `i` which
  is incremented with every consecutive application. ##}
pub let rec iteri { ?i : Int } f xs =
  match i with
  | None   => iteri {i = 0} f xs
  | Some i =>
    match xs with
    | []      => ()
    | x :: xs => f i x; iteri {i = i + 1} f xs
    end
  end

{## Apply a function to consecutive pairs of elements of the given lists.
  Calls `~onError` if the lists have different lengths. ##}
pub let iter2 { ~onError } f xs ys =
  let rec iter2Aux xs ys =
    match xs, ys with
    | [],      []      => ()
    | x :: xs, y :: ys => f x y; iter2Aux xs ys
    | _                => ~onError ()
    end
  in iter2Aux xs ys

{## `init n f` returns a list of n elements constructed by applying `f` to
  the index of current element. Optional parameter `i` sets the value of the
  starting index which by default is 0. ##}
pub let rec init { ?i : Int } (len : Int) f =
  match i with
  | None    => init {i = 0} len f
  | Some i =>
    let rec initAux (i : Int) f =
      if i >= len then []
      else f i :: initAux (i + 1) f
    in initAux i f
  end

## `foldLeft f init [x1, x2, ... ,xn]` is `f (... (f (f init x1) x2) ...) xn`.
pub let rec foldLeft f acc xs =
  match xs with
  | []      => acc
  | x :: xs => foldLeft f (f acc x) xs
  end

## `foldRight f [x1, x2, ..., xn] init` is `f x1 (f x2 (... (f xn init)))`.
pub let rec foldRight f xs acc =
  match xs with
  | []      => acc
  | x :: xs => f x (foldRight f xs acc)
  end

{## `foldLeft2 f init xs ys` works same as `List.foldLeft` but `f` is
  applied to consecutive pairs of elements from `xs` and `ys`.
  Calls `~onError` if the lists have different lengths. ##}
pub let foldLeft2 { ~onError } f acc xs ys =
  let rec foldLeft2Aux acc xs ys =
    match xs, ys with
    | [],      []      => acc
    | x :: xs, y :: ys => foldLeft2Aux (f acc x y) xs ys
    | _,       _       => ~onError ()
    end
  in foldLeft2Aux acc xs ys

## Same as `List.foldRight` and `List.foldLeft2`.
pub let foldRight2 { ~onError } f xs ys acc =
  let rec foldRight2Aux xs ys acc =
    match xs, ys with
    | [],      []      => acc
    | x :: xs, y :: ys => f x y (foldRight2Aux xs ys acc)
    | _,       _       => ~onError ()
    end
  in foldRight2Aux xs ys acc

## Check if all elements of a list satisfy a predicate.
pub let rec forAll p xs =
  match xs with
  | []      => True
  | x :: xs => p x && forAll p xs
  end

{## Check if all consecutive pairs of elements of the given lists satisfy `p`.
  Calls `~onError` if the lists have different lengths. ##}
pub let forAll2 { ~onError } p xs ys =
  let rec forAll2Aux xs ys =
    match xs, ys with
    | [],      []      => True
    | x :: xs, y :: ys => p x y && forAll2Aux xs ys
    | _,       _       => ~onError ()
    end
  in forAll2Aux xs ys

## Check if a list contains an element which satisfies a predicate.
pub let rec exists p xs =
  match xs with
  | []      => False
  | x :: xs => p x || exists p xs
  end

{## Check if there exists a pair of elements at the same position in the given
  lists that satisfies `p`.
  Calls `~onError` if the lists have different lengths. ##}
pub let exists2 { ~onError } p xs ys =
  let rec exists2Aux xs ys =
    match xs, ys with
    | [],      []      => False
    | x :: xs, y :: ys => p x y || exists2Aux xs ys
    | _,       _       => ~onError ()
    end
  in exists2Aux xs ys

{## Return the first element of a list that satisfies `p` or `None` if
  there is no such element. ##}
pub let rec find p xs =
  match xs with
  | []      => None
  | x :: xs => if p x then Some x else find p xs
  end

{## Return the first element of a list that satisfies `p` or call `~onError` if
  there is no such element. ##}
pub let findErr { ~onError } p xs =
  let rec findErrAux p xs =
    match xs with
    | []      => ~onError ()
    | x :: xs => if p x then x else findErrAux p xs
    end
  in findErrAux p xs

{## Return the index of the first element of a list that satisfies `p` or `None`
  if there is no such element. ##}
pub let findIndex p xs =
  let rec findIndexAux (i : Int) xs =
    match xs with
    | []      => None
    | x :: xs => if p x then Some i else findIndexAux (i + 1) xs
    end
  in findIndexAux 0 xs

{## Return the index of the first element of a list that satisfies `p` or call
  `~onError` if there is no such element. ##}
pub let findIndexErr { ~onError } p xs =
  let rec findIndexErrAux (i : Int) xs =
    match xs with
    | []      => ~onError ()
    | x :: xs => if p x then i else findIndexErrAux (i + 1) xs
    end
  in findIndexErrAux 0 xs

{## Return the first value returned as `Some v` after application of `f` to an
  element of the given list or `None` if there is no such result. ##}
pub let rec findMap f xs =
  match xs with
  | []      => None
  | x :: xs =>
    match f x with
    | Some x => Some x
    | None   => findMap f xs
    end
  end

{## Return the first value  returned as `Some v` after application of `f` to an
  element of the given list or call `~onError` if there is no such result. ##}
pub let findMapErr { ~onError } f xs =
  let rec findMapErrAux f xs =
    match xs with
    | []      => ~onError ()
    | x :: xs =>
      match f x with
      | None   => findMapErrAux f xs
      | Some x => x
      end
    end
  in findMapErrAux f xs

{## Same as `List.findMap`, but it takes an additional optional parameter `i`
  whose default value is 0 and `f` takes an additional argument `i` which is
  incremented with every consecutive application. ##}
pub let rec findMapi { ?i : Int } f xs =
  match i with
  | None   => findMapi {i = 0} f xs
  | Some i =>
    match xs with
    | []      => None
    | x :: xs =>
      match f i x with
      | Some x' => Some x'
      | None    => findMapi {i = i + 1} f xs
      end
    end
  end

{## Same as `List.findMapErr`, but it takes an additional optional parameter `i`
  whose default value is 0 and `f` takes an additional argument `i` which is
  incremented with every consecutive application. ##}
pub let rec findMapiErr { ~onError, ?i : Int } f xs =
  match i with
  | None   => findMapiErr {i = 0} f xs
  | Some i =>
    match xs with
    | []      => ~onError ()
    | x :: xs =>
      match f i x with
      | Some x => x
      | None   => findMapiErr {i = i + 1} f xs
      end
    end
  end

{## Return a pair whose first element is the same as `List.foldLeft` and its
  second element is a new list. `f` returns a pair of values, first being the
  new accumulator and second being a value added to the list in the result. ##}
pub let foldLeftMap f acc xs =
  let rec foldLeftMapAux acc l_acc xs =
    match xs with
    | []      => acc, rev l_acc
    | x :: xs =>
      let (acc, x) = f acc x in
      foldLeftMapAux acc (x :: l_acc) xs
    end
  in foldLeftMapAux acc [] xs

{## Same as `List.foldLeftMap`, but `f` returns an `Option` and the accumulator
  and constructed list are updated when the result of `f` is not `None`. ##}
pub let foldLeftFilterMap f acc xs =
  let rec foldLeftFilterMapAux acc l_acc xs =
    match xs with
    | []      => acc, rev l_acc
    | x :: xs =>
      match f acc x with
      | None          => foldLeftFilterMapAux acc l_acc xs
      | Some (acc, x) => foldLeftFilterMapAux acc (x :: l_acc) xs
      end
    end
  in foldLeftFilterMapAux acc [] xs

## Same as `List.foldLeftMap` but it concatenates the new list.
pub let foldLeftConcatMap f acc xs =
  let (acc, xs) = foldLeftMap f acc xs
  in (acc, concat xs)

## ## Operations on lists containing comparable elements

## Check if a list contains an element equal to the given value.
pub let mem
  { E, method equal : E -> E ->[] Bool }
  (v : E) (xs : List E) =
  let rec memAux (xs : List E) =
    match xs with
    | []      => False
    | x :: xs => v == x || memAux xs
    end
  in memAux xs

{## Check if two lists have the same lengths and their elements at equal
  positions are equal. ##}
pub let equal
  { E, method equal : E -> E ->[] Bool }
  (xs : List E) (ys : List E) =
  let rec equalAux (xs : List E) (ys : List E) =
    match xs, ys with
    | [],      []      => True
    | x :: xs, y :: ys => x == y && equalAux xs ys
    | _,       _       => False
    end
  in equalAux xs ys

# method versions of these functions
implicit ~onError

pub method isEmpty = isEmpty self
pub method length = length self
pub method hd = hd self
pub method hdErr = hdErr self
pub method tl = tl self
pub method tlErr = tlErr self
pub method nth n = nth self n
pub method nthErr n = nthErr self n
pub method append ys = append self ys
pub method add ys = append self ys
pub method revAppend ys = revAppend self ys
pub method rev = rev self
pub method concat = concat self
pub method map f = map f self
pub method mapi { ?i : Int } f = mapi { ?i = i } f self
pub method revMapAppend f ys = revMapAppend f self ys
pub method revMap f = revMap f self
pub method filter p = filter p self
pub method filteri { ?i : Int } p = filteri { ?i = i } p self
pub method filterMap f = filterMap f self
pub method concatMap f = concatMap f self
pub method drop n = drop n self
pub method takeWhile p = takeWhile p self
pub method dropWhile p = dropWhile p self
pub method iteri { ?i : Int } f = iteri { ?i = i } f self
pub method foldLeft f acc = foldLeft f acc self
pub method foldRight f acc = foldRight f self acc
pub method forAll p = forAll p self
pub method exists p = exists p self
pub method find p = find p self
pub method findErr p = findErr p self
pub method findIndex p = findIndex p self
pub method findIndexErr p = findIndexErr p self
pub method findMap f = findMap f self
pub method findMapErr f = findMapErr f self
pub method findMapi { ?i : Int } f = findMapi { ?i = i } f self
pub method findMapiErr { ?i : Int } f = findMapiErr { ?i = i } f self
pub method foldLeftMap f acc = foldLeftMap f acc self
pub method foldLeftFilterMap f acc = foldLeftFilterMap f acc self
pub method foldLeftConcatMap f acc = foldLeftConcatMap f acc self
pub method mem { E, method equal : E -> E ->[] Bool } v =
  mem {E} v self
pub method equal { E, method equal : E -> E ->[] Bool } xs =
  equal {E} self xs
pub method neq { E, method equal : E -> E ->[] Bool } xs =
  not (equal {E} self xs)
